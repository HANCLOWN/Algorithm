package main

import (
	"math"
	"strconv"
)

//给你一个整数 n ，以二进制字符串的形式返回该整数的 负二进制（base -2）表示。
//
//注意，除非字符串就是 "0"，否则返回的字符串中不能含有前导零。
//示例 1：
//输入：n = 2
//输出："110"
//解释：(-2)2 + (-2)1 = 2
//示例 2：
//输入：n = 3
//输出："111"
//解释：(-2)2 + (-2)1 + (-2)0 = 3
//示例 3：
//输入：n = 4
//输出："100"
//解释：(-2)2 = 4
//提示：
//0 <= n <= 109

func baseNeg2(n int) string {
	if n == 0 {
		return "0"
	}
	var result int
	var bitPos uint
	for n != 0 {
		remainder := n % -2
		n /= -2
		//如果余数小于0，对余数和商进行调整
		//我们详细解释一下处理原理
		//在进行负基数除法时，通常我们希望得到的余数在[0, 基数的绝对值)的范围内，即对于基数-2，我们想要得到的余数应该是0或1。这是因为在二进制（包括负二进制）表示中，每一位的值只能是0或1。
		//当我们得到一个负的余数时，我们为了保持等式的平衡，需要进行调整。这是因为我们在计算过程中实际上是在做下面的等式：
		// n = (-2) * q + r
		//其中n是我们要转换为负二进制的数，q是商，r是余数。
		//如果r小于0，我们通过加上基数的绝对值来调整它：( r = r + 2 )。这样做后，我们的等式就变成了：
		//n = (-2) * q + (r + 2)
		//由于我们增加了2到(r)上，为了保持等式的平衡，我们需要相应减少商(q)乘以的-2，因为我们实际上是把2“借”给了(r)。因此，我们可以从(q)那里补上这个“借”出去的2（因为(q)乘以-2的结果变小了），所以我们将商(q)增加1：
		//n = (-2) * (q + 1) + (r + 2 - 2)
		//简化上面的等式，我们得到：
		//n = (-2) * (q + 1) + r
		//这样，我们就保持了等式 n = (-2) * q + r 的平衡，同时确保了(r)是非负的。
		//所以当我们得到负的余数，并且调整它加上2之后，我们需要增加商(q)以补偿我们给(r)额外加上的值
		if remainder < 0 {
			remainder += 2
			n++
		}
		// 使用位操作将余数放置到正确的位置
		result |= remainder << bitPos
		bitPos++
	}
	// 转换成字符串表示
	return strconv.FormatInt(int64(result), 2)
}

// 引申出的进制转化器
func baseSwitch(n int, t int) string {
	if n == 0 {
		return "0"
	}
	var result string
	for n != 0 {
		remainder := n % t
		n /= t
		if remainder < 0 {
			remainder += int(math.Abs(float64(t)))
			n++
		}
		result = strconv.Itoa(remainder) + result
	}
	return result
}

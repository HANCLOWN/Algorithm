package main

//给你一个 rows x cols 的矩阵 grid 来表示一块樱桃地。 grid 中每个格子的数字表示你能获得的樱桃数目。
//你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。
//请你按照如下规则，返回两个机器人能收集的最多樱桃数目：
//从格子 (i,j) 出发，机器人可以移动到格子 (i+1, j-1)，(i+1, j) 或者 (i+1, j+1) 。
//当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。
//当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。
//两个机器人在任意时刻都不能移动到 grid 外面。
//两个机器人最后都要到达 grid 最底下一行。
//示例 1：
//输入：grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
//输出：24
//解释：机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。
//机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) = 12 。
//机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) = 12 。
//樱桃总数为： 12 + 12 = 24 。
//示例 2：
//输入：grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
//输出：28
//解释：机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。
//机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) = 17 。
//机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) = 11 。
//樱桃总数为： 17 + 11 = 28 。
//示例 3：
//输入：grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]
//输出：22
//示例 4：
//输入：grid = [[1,1],[1,1]]
//输出：4
//提示：
//rows == grid.length
//cols == grid[i].length
//2 <= rows, cols <= 70
//0 <= grid[i][j] <= 100

//这个问题可以使用动态规划（DP）来解决。我们可以使用一个三维DP数组，dp[i][j][k]，其中i和j表示机器人1的位置，k表示机器人2在同一行中的位置偏移量。dp[i][j][k]的值将表示当机器人1和机器人2到达这些位置时，他们可以收集的最大樱桃数。
//
//由于机器人们只能向下或者斜向下移动，我们从最底部的行开始处理，然后向上移动，直到我们到达顶部的行。然后，我们需要处理所有可能的机器人1和机器人2的位置。如果两个机器人在同一个位置，我们只添加一次樱桃数量。如果他们在两个不同的位置，我们添加这两个位置的樱桃数量。
//
//然后，我们考虑机器人们接下来可能的移动方向，即他们可以向下，向右下，或向左下移动。这意味着我们需要查看dp[i+1][j+dj][k+dk]的值，其中dj和dk属于集合{-1, 0, 1}。我们取所有可能的下一个位置的最大值，并将其添加到当前位置的樱桃数量中。
//
//最后，我们返回dp[0][0][cols-1]的值，这表示机器人1从左上角开始，机器人2从右上角开始他们可以收集的最大樱桃数。
//
//这个解决方案的时间复杂性为O(n^3)，其中n是行或列的数量。因为对于每个位置，我们需要检查9个可能的下一个位置。空间复杂性为O(n^2)，对于每个位置，我们需要存储一个值

func cherryPickupI(grid [][]int) int {
	rows := len(grid)
	cols := len(grid[0])
	// dp[i][j][k]: 最大樱桃数，其中机器人1在(i, j)且机器人2在(i, k)
	dp := make([][][]int, rows)
	for i := range dp {
		dp[i] = make([][]int, cols)
		for j := range dp[i] {
			dp[i][j] = make([]int, cols)
		}
	}

	// 初始化 dp 数组
	for i := 0; i < rows; i++ {
		for j := 0; j < cols; j++ {
			for k := 0; k < cols; k++ {
				dp[i][j][k] = -1
			}
		}
	}

	// 动态规划填表
	for i := rows - 1; i >= 0; i-- {
		for j := 0; j < cols; j++ {
			for k := 0; k < cols; k++ {
				value := 0
				if j == k {
					value = grid[i][j] // 如果两个机器人在同一个位置，只能取一次樱桃
				} else {
					value = grid[i][j] + grid[i][k]
				}
				if i == rows-1 {
					dp[i][j][k] = value
				} else {
					maxVal := 0
					for dj := -1; dj <= 1; dj++ {
						for dk := -1; dk <= 1; dk++ {
							nj, nk := j+dj, k+dk
							if nj >= 0 && nj < cols && nk >= 0 && nk < cols {
								maxVal = max(maxVal, dp[i+1][nj][nk])
							}
						}
					}
					dp[i][j][k] = value + maxVal
				}
			}
		}
	}

	return dp[0][0][cols-1]
}

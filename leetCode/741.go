package main

import "fmt"

//
//给你一个 n x n 的网格 grid ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：
//
//0 表示这个格子是空的，所以你可以穿过它。
//1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
//-1 表示这个格子里有荆棘，挡着你的路。
//请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：
//
//从位置 (0, 0) 出发，最后到达 (n - 1, n - 1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 0 或者 1 的格子）；
//当到达 (n - 1, n - 1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；
//当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 0 ）；
//如果在 (0, 0) 和 (n - 1, n - 1) 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。
//
//
//示例 1：
//
//
//输入：grid = [[0,1,-1],[1,0,-1],[1,1,1]]
//输出：5
//解释：玩家从 (0, 0) 出发：向下、向下、向右、向右移动至 (2, 2) 。
//在这一次行程中捡到 4 个樱桃，矩阵变成 [[0,1,-1],[0,0,-1],[0,0,0]] 。
//然后，玩家向左、向上、向上、向左返回起点，再捡到 1 个樱桃。
//总共捡到 5 个樱桃，这是最大可能值。
//示例 2：
//
//输入：grid = [[1,1,-1],[1,-1,1],[-1,1,1]]
//输出：0
//
//
//提示：
//
//n == grid.length
//n == grid[i].length
//1 <= n <= 50
//grid[i][j] 为 -1、0 或 1
//grid[0][0] != -1
//grid[n - 1][n - 1] != -1

// 首先，我们定义一个二维数组 dp，其中 dp[i][j] 表示从起点 (0, 0) 到达位置 (i, j) 并返回到起点的路径中能够摘到的最大樱桃数。
// 然后，我们可以使用动态规划的思想，从左上角 (0, 0) 开始，逐步计算到达每个位置的最大樱桃数。
// 具体的计算规则如下：对于每个位置 (i, j)，可以从上方 (i-1, j) 或者左方 (i, j-1) 到达。因为每个位置只能向下或向右移动，所以 (i, j) 的樱桃数只能来自于 (i-1, j) 或者 (i, j-1) 中较大的值加上 (i, j) 位置本身的樱桃数。
// 最后，返回 dp[n-1][n-1] 即可得到从起点到终点并返回起点能够摘到的最大樱桃数。

// 动态规划的思想
// 这个问题的解决方案采用了动态规划的方法。动态规划是一种通过把原问题分解为相对简单的子问题的方式来求解复杂问题的方法。在这个问题中，我们需要计算从起点 (0, 0) 到终点 (n - 1, n - 1) 并返回起点的过程中，能摘到的最大樱桃数。
//
// 定义状态
// dp[i][p] 表示两个同时进行的路径：一个路径从 (0, 0) 到 (i, j)，另一个路径从 (0, 0) 到 (p, q)，在这两条路径上能摘到的最大樱桃数。这里的 j 和 q 是通过当前的步数 k 和 i、p 的值计算得到的，因为在每一步中，两个路径都可以向下或向右移动。
//
// 状态转移方程
// 对于每个位置 (i, j) 和 (p, q)，我们考虑以下几种情况来更新 dp[i][p] 的值：
//
// 如果 i 和 p 都大于 0，我们需要考虑之前的状态 dp[i-1][p-1]，即两个路径分别从上方和左方到达当前位置。
// 如果只有 i 大于 0，我们考虑 dp[i-1][p]，即第一个路径从上方到达，第二个路径保持不变。
// 如果只有 p 大于 0，我们考虑 dp[i][p-1]，即第一个路径保持不变，第二个路径从左方到达。
// 在每一步中，我们选择上述情况中的最大值，并加上当前位置的樱桃数（如果两个路径到达的不是同一个格子，则需要加上两个格子的樱桃数；如果是同一个格子，则只加一次）。
//
// 边界条件
// 初始时，dp[0][0] 等于起点的樱桃数。
// 对于路径不可能到达的情况（例如，遇到 -1 表示的荆棘），我们将 dp[i][p] 设置为 -1，表示这是一个无效的状态。
// 计算结果
// 最终，dp[n-1][n-1] 的值就是我们要求的结果，即从 (0, 0) 到 (n - 1, n - 1) 并返回的过程中能摘到的最大樱桃数。如果这个值是负数，表示没有有效路径，返回 0。
//
// 辅助函数
// max 函数用于计算两个整数中的最大值，辅助我们在更新 dp 数组时选择最优解。
//
// 这个解决方案巧妙地通过动态规划同时考虑了去程和回程的路径，确保了在整个过程中能够摘到最多的樱桃。
//写在前面的话：这个解决方案使用了动态规划的方法来解决这个问题，通过计算从起点到终点并返回起点的过程中能够摘到的最大樱桃数。

// 但是现在以我的实力没有办法完全理解这个解决方案，等后面学习了动态规划，我会继续努力理解这个解决方案。
func cherryPickup(grid [][]int) int {
	n := len(grid)
	dp := make([][]int, n)
	for i := 0; i < n; i++ {
		dp[i] = make([]int, n)
	}
	dp[0][0] = grid[0][0]
	for k := 1; k <= 2*(n-1); k++ {
		for i := n - 1; i >= 0; i-- {
			for p := n - 1; p >= 0; p-- {
				j := k - i
				q := k - p
				fmt.Println("i, j, p, q, k:", i, j, p, q, k)
				if j < 0 || j >= n || q < 0 || q >= n || grid[i][j] == -1 || grid[p][q] == -1 {
					dp[i][p] = -1
					continue
				}
				if i > 0 {
					dp[i][p] = max(dp[i][p], dp[i-1][p])
				}
				if p > 0 {
					dp[i][p] = max(dp[i][p], dp[i][p-1])
				}
				if i > 0 && p > 0 {
					dp[i][p] = max(dp[i][p], dp[i-1][p-1])
				}
				if dp[i][p] >= 0 {
					dp[i][p] += grid[i][j]
					if i != p {
						dp[i][p] += grid[p][q]
					}
				}
			}
		}
		fmt.Println("dp:", dp)
	}
	return max(dp[n-1][n-1], 0)
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
